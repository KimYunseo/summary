1.시작하며

* 프로그래머

>프로그램을 만드는 사람

* 프로그래밍

>프로그램을 만드는 것

* 컴퓨터 프로그램

>컴퓨터가 읽을 수 있는 명령어로 이루어진 내용

* 컴퓨터

>1과 0을 통해 계산을 하는 기기


2.컴퓨터의 역사

* 진공관
* 트랜지스터
* 집적회로(IC)

3.컴퓨터의 구성

-하드웨어

>* 입력장치, 출력장치, 기억장치, 연산장치, 제어장치

>-주기억장치

>>* 램

>-보조기억장치

>>* 하드, 시디롬 등

-소프트웨어
>* 시스템소프트웨어, 응용소프트웨어

4.컴퓨터 구조

-하버드 구조

![하버드](https://github.com/KimYunseo/summary/blob/master/harvard.png?raw=true)

* 프로그램 메모리와 데이터 메모리가 물리적으로 분리

* 속도가 빠름(병목 X)

* 구성비용이 많이 들고 복잡


-폰 노이만 구조

![폰노이만](https://github.com/KimYunseo/summary/blob/master/von_neumann.png?raw=true)

* 프로그램메모리와 데이터메모리가 구분되어 있지 않고 하나의 버스를 가지고 있는 구조

* 메모리 속박 문제 (메모리가 CPU속도를 따라가지 못하여, CPU 대기시간이 길어지는 문제)와 버스 병목문제를 가짐

* 값이 싸고, 구조가 단순하다.

-폰 노이만 VS 하버드

* 최신컴퓨터 아키텍쳐는 하버드구조와 폰노이만 구조결합

* CPU 캐시메모리 형상 관여

>내부 - 하버드

>외부 - 폰 노이만

-캐시메모리

![캐시메모리](https://image-proxy.namuwikiusercontent.com/r/http%3A%2F%2Fcs.uwec.edu%2F~buipj%2Fteaching%2Fcs.352.f12%2Fstatic%2Fimage%2Fmemory_hierarchy.png)

>* CPU의 처리 속도와 DRAM과의 속도 차이로 인해 메모리 속박 문제 등이 발생 하는 대 이를 해결하기 위해 도입된 메모리이다.

>* DRAM의 명령어들을 미리 받아 저장하고 이를 CPU로 전해 주는 역할을 한다.

>* 

5.데이터의 표현

>* 왜 0, 1 만 사용하는가?

>* 16진수 사용 이유

>>10진수를 2진수 환산하는 것이 어려움

>>but 16진수를 2진수로 2진수로 16진수로 바꾸는 것이 쉬움

>> 10진수 : 0~9 10 11 12 13 14 15

>> 16진수 : 0~9 A  B  C  D  E  F

>>0x7BC3 에서 0x는 16진수를 의미한다.

-정수

>음의 정수 표현 : 2의 보수!

>1101 (맨 앞자리는 부호)

>0010 (반전)

>0001 (+)

>0011 <== 이를 2의 보수라 말함

-실수

-문자

6.논리연산

* CPU는 가산기이다. 즉 덧셈만 한다.

>* 따라서 곱셈도 더하기로 하며, 나눗셈은 뺄셈으로 한다.(나누기의 경우 6/2는 6에서 2를 총 3번 뺄 수 있다. 따라서 몫은 3이 나온다.)

비트연산
======
-AND(&) :  둘다 1일 경우에만 1이 된다.

| a  | 0  | 1  | 0  |  0 | 1  |
|:-:|:-:|:-:|:-:|:-:|:-:|
| b  | 0  | 1  | 0  | 1 | 0  |
| a&b  | 0  | 1  | 0  | 0   | 0  |

-OR(|) : 둘 중 하나라도 1이라면 1이된다.

| a  | 0  | 1  | 0  |  0 | 1  |
|:-:|:-:|:-:|:-:|:-:|:-:|
| b  | 0  | 1  | 0  | 1 | 0  |
| a`|`b  | 0  | 1  | 0  | 1   | 1  |

-NOT(~) : 반전을 시킨다.

| a  | 0  | 1  | 0  |  0 | 1  |
|:-:|:-:|:-:|:-:|:-:|:-:|
| ~a  | 1  | 0  | 1  | 1 | 0  |

** 버스의 크기가 4bit 일때 **

4bit 중 첫번째 자리는 부호이고 나머지 3자리가 수를 표현 총 10진수로 7까지의 수를 표현할 수 있다고 가정

>* 0110 - 0001 (10진수 6 - 1)

> =>CPU는 가산기 이므로 뺄셈 또한 더하기로 하여야 한다. 이때 2의 보수가 필요하다. 2의 보수를 하면 뺄셈을 덧셈으로 처리할 수 있다.

>>* 0001을 2의 보수화를 하면, 먼저 반전을 시켜주고( 1110 ), 그다음 1을 더해준다 (1111).

>* 0110 + 1111

>* 10101 이 나온다 하지만 총 4bit 만 표현 할 수 있으므로, 0101 (10진수 5)이 나온다. 

>>* 위의 상황 처럼 총 4bit로 표현이 가능한 것에 5bit가 표현되려 하면, 10101에서 첫번째 자리 1을 '오버플로우'라고 말한다.

>* 아래 표와 같이 7 ~ -8 까지 2진수로 표현하면(앞 자리는 부호 나머지 3자리가 숫자 표현),

|  0 | 0000  |   | 1000  |  -8 |
|:-:|:-:|:-:|:-:|:-:|
|  1 | 0001  |   | 1001  |  -7 |
|  2 | 0010  |   | 1010  |  -6 |
|  3 | 0011  |   | 1011  |  -5 |
|  4 | 0100  |   | 1100  |  -4 |
|  5 | 0101  |   | 1101  |  -3 |
|  6 | 0110  |   | 1110  |  -2 |
|  7 | 0111  |   | 1111  |  -1 |

> 위 표와 같을 때, 0111에 1을 더해주면 1000이 되고 이는 -8(10진수)이 된다. 이 또한 '오버플로우' 이다.

부울연산
======

|   | 비트연산자  | 부울연산자  |
|:-:|:-:|:-:|
| AND  | `&`  | `&&`  |
| OR  | `|`  |  `||` |
| NOT  | `~`  | `!`  |

* 부울 연산자는 참 거짓만 판별

* 0110 & 1101 = 0100

* 0110 && 1101 = TRUE

* TRUE && FALSE = FALSE

* => 1111 && 0000 = FALSE

* TRUE & FALSE = FALSE

* 1111 & 0000 = 0000


-XOR

-NOR

-NAND




1) 1101 & 1010

2) 1101 && 1010

3) 1110 | 1010

4) 1110 || 1010

5) true & false

6) true && false

7) true | false

8) true || false

연산 후 각 연산의 결과를10진수 및 16진수로 변환해 보세요.

* 1011 1101 & 0111 1010

* 1011 1101 | 0111 1010

* 0xAF & 0x8C

* 25(10) | 12(10)

* 25(10) & 12(10)

* ~1010 0011

* ~A8(16)

